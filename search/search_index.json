{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Vertama Manuals","text":"<p>\"Perfect is the enemy of good\" - Voltaire</p>"},{"location":"#intro","title":"Intro","text":"<p>Diese Seite wird automatisch aus vorhanden Unterlagen publiziert. Dieser Prozess ist im Fluss, und noch im Aufbau. Die bisher verf\u00fcgbare Dokumentation sind daher weder einheitlich noch vollst\u00e4ndig, wir bitten uns dies nachzusehen, und arbeiten kontinuierlich an der Verbesserung. Unsere Priorit\u00e4t ist die notwendige Dokumentation zum Betrieb, zur Integration und Entwicklung verf\u00fcgbar zur machen. Auch wenn die Form dabei manchmal zur\u00fcckstehen muss.</p>"},{"location":"#faq","title":"FAQ","text":""},{"location":"about/","title":"About","text":"<p>...to be written</p>"},{"location":"download/","title":"PDF Download","text":"<p>This sites documentation can be downloaded as PDF documents</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/","title":"Produkt\u00fcbersicht","text":""},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#elim-elektronische-infektionsmeldung","title":"ELIM - Elektronische Infektionsmeldung","text":"<p>Automatisiert. Sicher. Gesetzeskonform.</p> <p>Powered by VERTAMA</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#produktubersicht","title":"Produkt\u00fcbersicht","text":"<p>ELIM digitalisiert den Meldeprozess f\u00fcr meldepflichtige Infektionskrankheiten \u2013 direkt aus dem KIS, in Echtzeit und vollst\u00e4ndig gesetzeskonform. Die cloudbasierte L\u00f6sung ist auf die Umsetzung der gesetzlichen Anforderungen gem\u00e4\u00df \u00a7 6, 8, 9 IfSG ausgerichtet.</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#warum-elim","title":"Warum ELIM?","text":""},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#automatisiert-integriert","title":"Automatisiert &amp; integriert","text":"<p>ELIM \u00fcbernimmt den gesamten Meldeprozess \u2013 inklusive Formular, Versand, Empfangsquittung und Archivierung.</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#rechtssicher","title":"Rechtssicher","text":"<p>Unterst\u00fctzt s\u00e4mtliche gesetzlichen Anforderungen \u2013 inkl. Sonderregelungen</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#alle-meldewege","title":"Alle Meldewege","text":"<p>DEMIS (FHIR) f\u00fcr digitale Arztmeldungen, Fax f\u00fcr gesetzlich vorgeschriebene Ausnahmef\u00e4lle.</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#datenschutz-garantiert","title":"Datenschutz garantiert","text":"<p>Keine Speicherung sensibler Daten, Memento-Verschl\u00fcsselung, zertifiziert durch SAP BTP.</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#flexibel-konfigurierbar","title":"Flexibel konfigurierbar","text":"<p>Feste Faxziele oder individuelle Gesundheitsamt-regeln sind problemlos abbildbar.</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#schnell-einsatzbereit","title":"Schnell einsatzbereit","text":"<p>1\u20132 Tage Implementierung \u2013 kein notwendiger Schulungsaufwand, intuitiv f\u00fcr Nutzer.</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#so-funktioniert-elim-im-klinikalltag","title":"So funktioniert ELIM im Klinikalltag","text":""},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#1-meldung-starten","title":"1. Meldung starten","text":"<p>\u00dcber einen Button direkt aus der Patientenakte im KIS</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#2-datenubernahme","title":"2. Daten\u00fcbernahme","text":"<p>Formular ist automatisch mit vorhandenen Patientendaten vorausgef\u00fcllt</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#3-erganzen-absenden","title":"3. Erg\u00e4nzen &amp; Absenden","text":"<p>Ein Klick gen\u00fcgt \u2013 ELIM erkennt den korrekten Meldeweg</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#4-empfang-archivierung","title":"4. Empfang &amp; Archivierung","text":"<p>Quittung wird automatisch revisionssicher in der Patientenakte abgelegt</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#datenschutz-kein-thema-elim-speichert-nichts","title":"Datenschutz? Kein Thema \u2013 ELIM speichert nichts.","text":"<ul> <li>Keine zentrale Datenspeicherung: Alle Daten werden nach erfolgreicher \u00dcbermittlung automatisch gel\u00f6scht</li> <li>Ende-zu-Ende verschl\u00fcsselt: Sicherer Transport und Zugriffskontrolle</li> <li>Revisionssicher &amp; DSGVO-konform: Vollst\u00e4ndige Protokollierung aller Vorg\u00e4nge</li> </ul>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#ihre-vorteile-auf-einen-blick","title":"Ihre Vorteile auf einen Blick","text":"<p>\u2713 44 vordefinierte Meldeformulare - direkt im KIS w\u00e4hlbar</p> <p>\u2713 DEMIS-Anbindung per FHIR - direkter, gesetzeskonformer Versand</p> <p>\u2713 Fax-Funktion integriert - f\u00fcr Arztmeldungen au\u00dferhalb DEMIS Kompatibilit\u00e4t</p> <p>\u2713 Revisionssichere Ablage - in Patientenakte &amp; Archivsystem</p> <p>\u2713 Kein zus\u00e4tzlicher Personalaufwand - wartungsarm, updatesicher, intuitiv</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#elim-automatisch-melden-sicher-dokumentieren","title":"ELIM \u2013 Automatisch melden. Sicher dokumentieren.","text":"<p>F\u00fcr ein Gesundheitssystem, das Infektionsschutz einfacher macht.</p>"},{"location":"Products/ELIM/onepager/ELIM%20%E2%80%93%20Marketing%20Produktbeschreibung/#kontakt","title":"Kontakt","text":"<p>Jetzt mehr erfahren: - Website: www.vertama.com - E-Mail: andre.sturm@vertama.com</p> <p>\u00a9 VERTAMA - ELIM Elektronische Infektionsmeldung</p>"},{"location":"Products/ELIM/onepager/OnePager%20%28HTML%29/","title":"One Pager / Flyer (HTML)","text":"ELIM VERTAMA Elektronische Infektionsmeldung Automatisiert. Sicher. Gesetzeskonform. ELIM digitalisiert den Meldeprozess f\u00fcr meldepflichtige Infektionskrankheiten \u2013 direkt aus dem KIS, in Echtzeit und vollst\u00e4ndig gesetzeskonform. Die cloudbasierte L\u00f6sung ist auf die Umsetzung der gesetzlichen Anforderungen gem\u00e4\u00df \u00a7 6, 8, 9 IfSG ausgerichtet.          Warum ELIM? <ul> <li>Automatisiert &amp; integriert: ELIM \u00fcbernimmt den gesamten Meldeprozess \u2013 inklusive Formular, Versand, Empfangsquittung und Archivierung.</li> <li>Rechtssicher: Unterst\u00fctzt s\u00e4mtliche gesetzlichen Anforderungen \u2013 inkl. Sonderregelungen</li> <li>Alle Meldewege: DEMIS (FHIR) f\u00fcr digitale Arztmeldungen, Fax f\u00fcr gesetzlich vorgeschriebene Ausnahmef\u00e4lle.</li> <li>Datenschutz garantiert: Keine Speicherung sensibler Daten, Memento-Verschl\u00fcsselung, zertifiziert durch SAP BTP.</li> <li>Flexibel konfigurierbar: Feste Faxziele oder individuelle Gesundheitsamt-regeln sind problemlos abbildbar.</li> <li>Schnell einsatzbereit: 1\u20132 Tage Implementierung \u2013 kein notwendiger Schulungsaufwand, intuitiv f\u00fcr Nutzer.</li> </ul> So funktioniert ELIM im Klinikalltag 1 Meldung starten <p>\u00dcber einen Button direkt aus der Patientenakte im KIS</p> 2 Daten\u00fcbernahme <p>Formular ist automatisch mit vorhandenen Patientendaten vorausgef\u00fcllt</p> 3 Erg\u00e4nzen &amp; Absenden <p>Ein Klick gen\u00fcgt \u2013 ELIM erkennt den korrekten Meldeweg</p> 4 Empfang &amp; Archivierung <p>Quittung wird automatisch revisionssicher in der Patientenakte abgelegt</p> Datenschutz? Kein Thema \u2013 ELIM speichert nichts. <ul> <li>Keine zentrale Datenspeicherung: Alle Daten werden nach erfolgreicher \u00dcbermittlung automatisch gel\u00f6scht</li> <li>Ende-zu-Ende verschl\u00fcsselt: Sicherer Transport und Zugriffskontrolle</li> <li>Revisionssicher &amp; DSGVO-konform: Vollst\u00e4ndige Protokollierung aller Vorg\u00e4nge</li> </ul> Ihre Vorteile auf einen Blick 44 vordefinierte Meldeformulare - direkt im KIS w\u00e4hlbar DEMIS-Anbindung per FHIR - direkter, gesetzeskonformer Versand Fax-Funktion integriert - f\u00fcr Arztmeldungen au\u00dferhalb DEMIS Kompatibilit\u00e4t Revisionssichere Ablage - in Patientenakte &amp; Archivsystem Kein zus\u00e4tzlicher Personalaufwand - wartungsarm, updatesicher, intuitiv ELIM \u2013 Automatisch melden. Sicher dokumentieren. <p>F\u00fcr ein Gesundheitssystem, das Infektionsschutz einfacher macht.</p> <p>Jetzt mehr erfahren: www.vertama.com |              andre.sturm@vertama.com</p>"},{"location":"Products/ELIM/onepager/OnePager%20%28PNG%29/","title":"One Pager / Flyer (PNG)","text":""},{"location":"Products/ELIM/onepager/OnePager/","title":"One Pager / Flyer (TEXT/Markdown)","text":""},{"location":"Products/ELIM/onepager/OnePager/#elim-elektronische-infektionsmeldung","title":"ELIM - Elektronische Infektionsmeldung","text":"<p>Automatisiert. Sicher. Gesetzeskonform.</p> <p>Powered by VERTAMA</p>"},{"location":"Products/ELIM/onepager/OnePager/#produktubersicht","title":"Produkt\u00fcbersicht","text":"<p>ELIM digitalisiert den Meldeprozess f\u00fcr meldepflichtige Infektionskrankheiten \u2013 direkt aus dem KIS, in Echtzeit und vollst\u00e4ndig gesetzeskonform. Die cloudbasierte L\u00f6sung ist auf die Umsetzung der gesetzlichen Anforderungen gem\u00e4\u00df \u00a7 6, 8, 9 IfSG ausgerichtet.</p>"},{"location":"Products/ELIM/onepager/OnePager/#warum-elim","title":"Warum ELIM?","text":""},{"location":"Products/ELIM/onepager/OnePager/#automatisiert-integriert","title":"Automatisiert &amp; integriert","text":"<p>ELIM \u00fcbernimmt den gesamten Meldeprozess \u2013 inklusive Formular, Versand, Empfangsquittung und Archivierung.</p>"},{"location":"Products/ELIM/onepager/OnePager/#rechtssicher","title":"Rechtssicher","text":"<p>Unterst\u00fctzt s\u00e4mtliche gesetzlichen Anforderungen \u2013 inkl. Sonderregelungen</p>"},{"location":"Products/ELIM/onepager/OnePager/#alle-meldewege","title":"Alle Meldewege","text":"<p>DEMIS (FHIR) f\u00fcr digitale Arztmeldungen, Fax f\u00fcr gesetzlich vorgeschriebene Ausnahmef\u00e4lle.</p>"},{"location":"Products/ELIM/onepager/OnePager/#datenschutz-garantiert","title":"Datenschutz garantiert","text":"<p>Keine Speicherung sensibler Daten, Memento-Verschl\u00fcsselung, zertifiziert durch SAP BTP.</p>"},{"location":"Products/ELIM/onepager/OnePager/#flexibel-konfigurierbar","title":"Flexibel konfigurierbar","text":"<p>Feste Faxziele oder individuelle Gesundheitsamt-regeln sind problemlos abbildbar.</p>"},{"location":"Products/ELIM/onepager/OnePager/#schnell-einsatzbereit","title":"Schnell einsatzbereit","text":"<p>1\u20132 Tage Implementierung \u2013 kein notwendiger Schulungsaufwand, intuitiv f\u00fcr Nutzer.</p>"},{"location":"Products/ELIM/onepager/OnePager/#so-funktioniert-elim-im-klinikalltag","title":"So funktioniert ELIM im Klinikalltag","text":""},{"location":"Products/ELIM/onepager/OnePager/#1-meldung-starten","title":"1. Meldung starten","text":"<p>\u00dcber einen Button direkt aus der Patientenakte im KIS</p>"},{"location":"Products/ELIM/onepager/OnePager/#2-datenubernahme","title":"2. Daten\u00fcbernahme","text":"<p>Formular ist automatisch mit vorhandenen Patientendaten vorausgef\u00fcllt</p>"},{"location":"Products/ELIM/onepager/OnePager/#3-erganzen-absenden","title":"3. Erg\u00e4nzen &amp; Absenden","text":"<p>Ein Klick gen\u00fcgt \u2013 ELIM erkennt den korrekten Meldeweg</p>"},{"location":"Products/ELIM/onepager/OnePager/#4-empfang-archivierung","title":"4. Empfang &amp; Archivierung","text":"<p>Quittung wird automatisch revisionssicher in der Patientenakte abgelegt</p>"},{"location":"Products/ELIM/onepager/OnePager/#datenschutz-kein-thema-elim-speichert-nichts","title":"Datenschutz? Kein Thema \u2013 ELIM speichert nichts.","text":"<ul> <li>Keine zentrale Datenspeicherung: Alle Daten werden nach erfolgreicher \u00dcbermittlung automatisch gel\u00f6scht</li> <li>Ende-zu-Ende verschl\u00fcsselt: Sicherer Transport und Zugriffskontrolle</li> <li>Revisionssicher &amp; DSGVO-konform: Vollst\u00e4ndige Protokollierung aller Vorg\u00e4nge</li> </ul>"},{"location":"Products/ELIM/onepager/OnePager/#ihre-vorteile-auf-einen-blick","title":"Ihre Vorteile auf einen Blick","text":"<p>\u2713 44 vordefinierte Meldeformulare - direkt im KIS w\u00e4hlbar</p> <p>\u2713 DEMIS-Anbindung per FHIR - direkter, gesetzeskonformer Versand</p> <p>\u2713 Fax-Funktion integriert - f\u00fcr Arztmeldungen au\u00dferhalb DEMIS Kompatibilit\u00e4t</p> <p>\u2713 Revisionssichere Ablage - in Patientenakte &amp; Archivsystem</p> <p>\u2713 Kein zus\u00e4tzlicher Personalaufwand - wartungsarm, updatesicher, intuitiv</p>"},{"location":"Products/ELIM/onepager/OnePager/#elim-automatisch-melden-sicher-dokumentieren","title":"ELIM \u2013 Automatisch melden. Sicher dokumentieren.","text":"<p>F\u00fcr ein Gesundheitssystem, das Infektionsschutz einfacher macht.</p>"},{"location":"Products/ELIM/onepager/OnePager/#kontakt","title":"Kontakt","text":"<p>Jetzt mehr erfahren: - Website: www.vertama.com - E-Mail: andre.sturm@vertama.com</p> <p>\u00a9 VERTAMA - ELIM Elektronische Infektionsmeldung</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/","title":"Multi-User Secret Sharing - API Usage Guide","text":"<p>Audience: Developers integrating with or consuming this API Companion to: Multi-User Secret Sharing with Zero-Knowledge Architecture.md</p> <p>This guide shows how to use the secret sharing service with practical code examples.</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Quick Start</li> <li>Core Operations</li> <li>Advanced Usage</li> <li>Error Handling</li> <li>Security Best Practices</li> </ol>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#quick-start","title":"Quick Start","text":""},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>User must have an <code>ApiUser</code> account with a valid <code>userId</code></li> <li>User must have a password (never stored, only used for key derivation)</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#basic-flow","title":"Basic Flow","text":"<pre><code>// 1. Setup (once per user)\nservice.setupUserKeys(userId = 1L, password = \"user-password\")\n\n// 2. Create secret (by owner)\nval secretId = service.createSecret(\n    userId = 1L,\n    password = \"user-password\",\n    name = \"Database Credentials\",\n    value = \"postgresql://user:pass@host:5432/db\"\n)\n\n// 3. Access secret (by owner or granted user)\nval decrypted = service.accessSecret(\n    userId = 1L,\n    password = \"user-password\",\n    secretId = secretId\n)\n\nprintln(decrypted) // \"postgresql://user:pass@host:5432/db\"\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#core-operations","title":"Core Operations","text":""},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#1-setup-user-keys","title":"1. Setup User Keys","text":"<p>When: Once per user, before they can create or access secrets</p> <p>What it does: Generates X25519 key pair, encrypts private key with password-derived key</p> <pre><code>service.setupUserKeys(\n    userId = 123L,\n    password = \"user-chosen-password\"\n)\n</code></pre> <p>Returns: Nothing (throws exception on error)</p> <p>Errors: - <code>IllegalStateException</code>: User already has keys (call once only)</p> <p>Notes: - Password is never stored - Server derives encryption key from password using Argon2id - Private key is encrypted and stored; public key stored in plaintext - If user forgets password, all their secrets are permanently lost</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#2-create-secret","title":"2. Create Secret","text":"<p>When: User wants to store encrypted data</p> <p>What it does: Encrypts secret with random DEK, encrypts DEK with user's public key</p> <pre><code>// Option A: With password (derives KEK, ~200ms)\nval secretId: UUID = service.createSecret(\n    userId = 123L,\n    password = \"user-password\",\n    name = \"API Key\",\n    value = \"sk_live_abc123xyz789\"\n)\n\n// Option B: With pre-derived KEK from session (~1ms)\nval kek = session.getUserKek()\nval secretId: UUID = service.createSecret(\n    userId = 123L,\n    kek = kek,\n    name = \"API Key\",\n    value = \"sk_live_abc123xyz789\"\n)\n</code></pre> <p>Parameters: - <code>userId</code>: User creating the secret - <code>password</code> OR <code>kek</code>: Authentication credential - <code>name</code>: Human-readable label (stored in plaintext) - <code>value</code>: Secret data to encrypt (any string)</p> <p>Returns: <code>UUID</code> - unique identifier for the secret</p> <p>Errors: - <code>SecurityException</code>: Wrong password or user has no keys</p> <p>Notes: - Only the creator has access initially - Creator must use <code>grantAccess()</code> to share with others</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#3-access-secret","title":"3. Access Secret","text":"<p>When: User wants to decrypt and read a secret</p> <p>What it does: Decrypts user's private key, decrypts DEK, decrypts secret</p> <pre><code>// With password\nval decrypted: String = service.accessSecret(\n    userId = 123L,\n    password = \"user-password\",\n    secretId = UUID.fromString(\"...\")\n)\n\n// With KEK from session (faster)\nval kek = session.getUserKek()\nval decrypted: String = service.accessSecret(\n    userId = 123L,\n    kek = kek,\n    secretId = UUID.fromString(\"...\")\n)\n</code></pre> <p>Parameters: - <code>userId</code>: User accessing the secret - <code>password</code> OR <code>kek</code>: Authentication credential - <code>secretId</code>: UUID of the secret</p> <p>Returns: Decrypted secret value (plaintext string)</p> <p>Errors: - <code>SecurityException</code>: Wrong password, no access, or secret not found</p> <p>Notes: - User must have been granted access (creator has implicit access) - Password must be correct (no retry logic built-in)</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#4-grant-access","title":"4. Grant Access","text":"<p>When: User wants to share a secret with another user</p> <p>What it does: Re-encrypts DEK with grantee's public key</p> <pre><code>service.grantAccess(\n    secretId = UUID.fromString(\"...\"),\n    granterUserId = 123L,\n    granterPassword = \"granter-password\",\n    granteeUserId = 456L\n)\n</code></pre> <p>Parameters: - <code>secretId</code>: Secret to share - <code>granterUserId</code>: User granting access (must already have access) - <code>granterPassword</code>: Granter's password (to decrypt DEK) - <code>granteeUserId</code>: User receiving access</p> <p>Returns: Nothing (throws exception on error)</p> <p>Errors: - <code>SecurityException</code>: Granter doesn't have access, wrong password, or grantee has no keys</p> <p>Key insights: - Grantee doesn't need to be online - only their public key is used - Grantee's password is never shared - each user decrypts with their own password - Granter needs their password to decrypt the DEK, then re-encrypts it for grantee</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#5-revoke-access","title":"5. Revoke Access","text":"<p>When: User wants to remove another user's access</p> <p>What it does: Deletes user's encrypted DEK entry</p> <pre><code>service.revokeAccess(\n    secretId = UUID.fromString(\"...\"),\n    userId = 456L\n)\n</code></pre> <p>Parameters: - <code>secretId</code>: Secret to revoke access to - <code>userId</code>: User to revoke access from</p> <p>Returns: Nothing</p> <p>Limitations: - If user already decrypted and saved the secret, revocation doesn't affect saved copies - No password required (administrative action) - Cannot revoke creator's access (database constraint prevents it)</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#6-rotate-password","title":"6. Rotate Password","text":"<p>When: User wants to change their password</p> <p>What it does: Re-encrypts private key with new password-derived key</p> <pre><code>service.rotateUserPassword(\n    userId = 123L,\n    oldPassword = \"current-password\",\n    newPassword = \"new-secure-password\"\n)\n</code></pre> <p>Parameters: - <code>userId</code>: User changing password - <code>oldPassword</code>: Current password (must be correct) - <code>newPassword</code>: New password to set</p> <p>Returns: Nothing (throws exception on error)</p> <p>Errors: - <code>SecurityException</code>: Wrong old password</p> <p>Notes: - All secrets remain accessible with new password - Private key (and thus DEKs) stay the same, just re-encrypted - Old password is immediately invalidated</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#advanced-usage","title":"Advanced Usage","text":""},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#multi-user-workflow","title":"Multi-User Workflow","text":"<pre><code>// Alice creates secret\nservice.setupUserKeys(userId = alice.id, password = \"alice-pass\")\nval secretId = service.createSecret(\n    userId = alice.id,\n    password = \"alice-pass\",\n    name = \"Shared Database\",\n    value = \"prod-db-credentials\"\n)\n\n// Bob sets up keys\nservice.setupUserKeys(userId = bob.id, password = \"bob-pass\")\n\n// Alice grants Bob access (Bob doesn't need to be online!)\nservice.grantAccess(\n    secretId = secretId,\n    granterUserId = alice.id,\n    granterPassword = \"alice-pass\",\n    granteeUserId = bob.id\n)\n\n// Bob accesses with his own password\nval decrypted = service.accessSecret(\n    userId = bob.id,\n    password = \"bob-pass\",  // Not Alice's password!\n    secretId = secretId\n)\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#checking-access-before-granting","title":"Checking Access Before Granting","text":"<pre><code>// Repository method available\nval hasAccess = accessRepo.existsBySecretIdAndUserId(secretId, userId)\nif (!hasAccess) {\n    service.grantAccess(...)\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#listing-users-secrets","title":"Listing User's Secrets","text":"<pre><code>val userAccess: List&lt;UserSecretAccess&gt; = accessRepo.findByUserId(userId)\nuserAccess.forEach { access -&gt;\n    println(\"Secret: ${access.secret.name}\")\n    println(\"Granted by: ${access.grantedBy.name}\")\n    println(\"Granted at: ${access.grantedAt}\")\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#listing-users-with-access-to-secret","title":"Listing Users With Access to Secret","text":"<pre><code>val accessList: List&lt;UserSecretAccess&gt; = accessRepo.findBySecretId(secretId)\naccessList.forEach { access -&gt;\n    println(\"User: ${access.user.name}\")\n    println(\"Granted by: ${access.grantedBy.name}\")\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#error-handling","title":"Error Handling","text":""},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#securityexception","title":"SecurityException","text":"<p>Most operations throw <code>SecurityException</code> on auth failures:</p> <pre><code>try {\n    val secret = service.accessSecret(userId, password, secretId)\n} catch (e: SecurityException) {\n    when {\n        e.message?.contains(\"Wrong password\") == true -&gt;\n            // Password incorrect\n        e.message?.contains(\"has no access\") == true -&gt;\n            // User not granted access\n        e.message?.contains(\"has no crypto keys\") == true -&gt;\n            // User hasn't called setupUserKeys()\n        else -&gt;\n            // Other security error\n    }\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#illegalstateexception","title":"IllegalStateException","text":"<pre><code>try {\n    service.setupUserKeys(userId, password)\n} catch (e: IllegalStateException) {\n    // User already has keys - cannot call twice\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#recommended-error-handling-pattern","title":"Recommended Error Handling Pattern","text":"<pre><code>fun accessSecretSafely(userId: Long, password: String, secretId: UUID): Result&lt;String&gt; {\n    return try {\n        Result.success(service.accessSecret(userId, password, secretId))\n    } catch (e: SecurityException) {\n        Result.failure(e)\n    }\n}\n\n// Usage\naccessSecretSafely(userId, password, secretId)\n    .onSuccess { secret -&gt; println(\"Decrypted: $secret\") }\n    .onFailure { error -&gt; logger.error(\"Access failed: ${error.message}\") }\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#security-best-practices","title":"Security Best Practices","text":""},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#1-password-handling","title":"1. Password Handling","text":"<p>\u274c Don't:</p> <pre><code>// Never store passwords\ndata class User(val password: String)  // BAD!\n\n// Never log passwords\nlogger.info(\"User password: $password\")  // BAD!\n</code></pre> <p>\u2705 Do:</p> <pre><code>// Accept password as parameter, use immediately, discard\nfun login(username: String, password: String) {\n    service.accessSecret(userId, password, secretId)\n    // password garbage-collected after function returns\n}\n\n// Use char arrays for passwords (can be cleared)\nfun login(username: String, password: CharArray) {\n    try {\n        val passwordStr = String(password)\n        service.accessSecret(userId, passwordStr, secretId)\n    } finally {\n        password.fill('0')  // Clear password from memory\n    }\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#2-access-control","title":"2. Access Control","text":"<pre><code>// Check user owns or has access before operations\nfun userCanAccess(userId: Long, secretId: UUID): Boolean {\n    return accessRepo.existsBySecretIdAndUserId(secretId, userId)\n}\n\n// Verify before granting (prevent over-sharing)\nfun grantIfNotAlready(secretId: UUID, granterUserId: Long, ...) {\n    if (!userCanAccess(granteeUserId, secretId)) {\n        service.grantAccess(...)\n    }\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#3-error-messages","title":"3. Error Messages","text":"<p>\u274c Don't leak information:</p> <pre><code>catch (e: SecurityException) {\n    // Reveals whether user exists\n    return \"User $userId doesn't have crypto keys\"\n}\n</code></pre> <p>\u2705 Use generic messages:</p> <pre><code>catch (e: SecurityException) {\n    logger.warn(\"Access denied for user $userId\", e)\n    return \"Access denied\"  // Generic message to client\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#4-rate-limiting","title":"4. Rate Limiting","text":"<p>Implement rate limiting to prevent brute-force attacks:</p> <pre><code>@RateLimited(maxAttempts = 5, windowSeconds = 60)\nfun accessSecret(userId: Long, password: String, secretId: UUID): String {\n    return service.accessSecret(userId, password, secretId)\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#5-audit-logging","title":"5. Audit Logging","text":"<p>Log all access operations (but not passwords or secrets):</p> <pre><code>fun accessSecret(userId: Long, password: String, secretId: UUID): String {\n    val result = try {\n        service.accessSecret(userId, password, secretId)\n    } catch (e: SecurityException) {\n        auditLog.warn(\"Failed secret access\", mapOf(\n            \"userId\" to userId,\n            \"secretId\" to secretId,\n            \"reason\" to e.message\n        ))\n        throw e\n    }\n\n    auditLog.info(\"Secret accessed\", mapOf(\n        \"userId\" to userId,\n        \"secretId\" to secretId\n    ))\n\n    return result\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#6-password-rotation-reminders","title":"6. Password Rotation Reminders","text":"<pre><code>fun checkPasswordAge(userId: Long) {\n    val keys = userKeysRepo.findById(userId).orElseThrow()\n    val daysSinceCreation = ChronoUnit.DAYS.between(keys.createdAt, Instant.now())\n\n    if (daysSinceCreation &gt; 90) {\n        notifyUser(userId, \"Consider rotating your password\")\n    }\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#performance-considerations","title":"Performance Considerations","text":""},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#kdf-latency","title":"KDF Latency","text":"<p>Each password-based operation triggers Argon2id key derivation (~100-500ms). For better performance, use KEK-based method overloads with session-stored KEK:</p> <pre><code>// Slow: Derives KEK on every call\nrepeat(10) {\n    service.accessSecret(userId, password, secretId)  // 10 \u00d7 200ms = 2000ms\n}\n\n// Fast: Derive KEK once, reuse from session\nval kek = session.getUserKek()  // Already derived at login\nrepeat(10) {\n    service.accessSecret(userId, kek, secretId)  // 10 \u00d7 &lt;1ms = ~10ms\n}\n</code></pre> <p>Recommendation: Use session-based KEK for normal operations. Reserve password-based methods for high-security actions requiring explicit confirmation.</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#database-queries","title":"Database Queries","text":"<p>Operations by query count:</p> <ul> <li><code>setupUserKeys()</code>: 1 write</li> <li><code>createSecret()</code>: 3 reads, 2 writes</li> <li><code>accessSecret()</code>: 3 reads</li> <li><code>grantAccess()</code>: 4 reads, 1 write</li> <li><code>revokeAccess()</code>: 1 delete</li> </ul> <p>Recommendation: Add indexes on <code>user_secret_access(secret_id, user_id)</code> for optimal performance.</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#integration-examples","title":"Integration Examples","text":""},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#spring-mvc-controller","title":"Spring MVC Controller","text":"<pre><code>@RestController\n@RequestMapping(\"/api/secrets\")\nclass SecretController(\n    private val service: Service,\n    private val accessRepo: UserSecretAccessRepository\n) {\n\n    @PostMapping\n    fun createSecret(\n        @AuthenticationPrincipal user: ApiUser,\n        @RequestParam password: String,\n        @RequestBody request: CreateSecretRequest\n    ): ResponseEntity&lt;SecretResponse&gt; {\n        val secretId = service.createSecret(\n            userId = user.id!!,\n            password = password,\n            name = request.name,\n            value = request.value\n        )\n\n        return ResponseEntity.ok(SecretResponse(secretId))\n    }\n\n    @GetMapping(\"/{secretId}\")\n    fun getSecret(\n        @AuthenticationPrincipal user: ApiUser,\n        @PathVariable secretId: UUID,\n        @RequestParam password: String\n    ): ResponseEntity&lt;String&gt; {\n        return try {\n            val decrypted = service.accessSecret(user.id!!, password, secretId)\n            ResponseEntity.ok(decrypted)\n        } catch (e: SecurityException) {\n            ResponseEntity.status(HttpStatus.FORBIDDEN).build()\n        }\n    }\n\n    @PostMapping(\"/{secretId}/grant\")\n    fun grantAccess(\n        @AuthenticationPrincipal user: ApiUser,\n        @PathVariable secretId: UUID,\n        @RequestParam password: String,\n        @RequestParam granteeUserId: Long\n    ): ResponseEntity&lt;Void&gt; {\n        service.grantAccess(secretId, user.id!!, password, granteeUserId)\n        return ResponseEntity.ok().build()\n    }\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#thymeleaf-template","title":"Thymeleaf Template","text":"<pre><code>&lt;!-- Create secret form --&gt;\n&lt;form th:action=\"@{/secrets}\" method=\"post\"&gt;\n    &lt;input type=\"text\" name=\"name\" placeholder=\"Secret name\" required /&gt;\n    &lt;textarea name=\"value\" placeholder=\"Secret value\" required&gt;&lt;/textarea&gt;\n    &lt;input type=\"password\" name=\"password\" placeholder=\"Your password\" required /&gt;\n    &lt;button type=\"submit\"&gt;Create Secret&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;!-- Access secret --&gt;\n&lt;form th:action=\"@{/secrets/{id}/view(id=${secretId})}\" method=\"post\"&gt;\n    &lt;input type=\"password\" name=\"password\" placeholder=\"Your password\" required /&gt;\n    &lt;button type=\"submit\"&gt;Decrypt&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;!-- Display decrypted (be careful with XSS!) --&gt;\n&lt;div th:if=\"${decrypted}\"&gt;\n    &lt;pre th:text=\"${decrypted}\"&gt;&lt;/pre&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#user-has-no-crypto-keys","title":"\"User has no crypto keys\"","text":"<p>Cause: User hasn't called <code>setupUserKeys()</code> yet</p> <p>Fix: Call <code>setupUserKeys()</code> once per user before other operations</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#wrong-password-or-corrupted-private-key","title":"\"Wrong password or corrupted private key\"","text":"<p>Cause: Password is incorrect</p> <p>Fix: Verify user entered correct password</p> <p>Note: No password recovery possible - forgotten password = lost secrets</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#user-has-no-access-to-secret","title":"\"User has no access to secret\"","text":"<p>Cause: User wasn't granted access</p> <p>Fix: Secret creator must call <code>grantAccess()</code> first</p>"},{"location":"background-and-explanations/security-and-encryption/API-Usage-Guide/#user-already-has-keys","title":"\"User already has keys\"","text":"<p>Cause: Called <code>setupUserKeys()</code> twice for same user</p> <p>Fix: Only call once; use <code>rotateUserPassword()</code> to change password</p> <p>Document Version: 1.0 Last Updated: 2025-10-14 Related: - Multi-User Secret Sharing with Zero-Knowledge Architecture.md - Implementation-Notes.md</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/","title":"Multi-User Secret Sharing - Implementation Notes","text":"<p>Audience: Developers working on or extending this implementation Companion to: Multi-User Secret Sharing with Zero-Knowledge Architecture.md</p> <p>This document captures practical implementation details, gotchas, and lessons learned that aren't covered in the architectural design document.</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#table-of-contents","title":"Table of Contents","text":"<ol> <li>JPA/Hibernate Considerations</li> <li>Testing Strategy</li> <li>Common Pitfalls</li> <li>Performance Tips</li> <li>Memory Management</li> </ol>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#entity-classes-diagram","title":"Entity Classes Diagram","text":"<pre><code>classDiagram\n    class ApiUser {\n        +Long id\n        +String userName\n        +String password\n        +List~String~ roles\n    }\n\n    class UserCryptoKeys {\n        +Long userId\n        +ByteArray publicKey\n        +ByteArray encryptedPrivateKey\n        +ByteArray privateKeyKDFSalt\n        +ByteArray privateKeyIV\n        +Int kdfIterations\n        +Int kdfMemoryKb\n        +Instant createdAt\n    }\n\n    class SharedSecret {\n        +UUID id\n        +String name\n        +ByteArray encryptedSecret\n        +ByteArray secretIV\n        +Instant createdAt\n    }\n\n    class UserSecretAccess {\n        +ByteArray encryptedDEK\n        +ByteArray dekIV\n        +Instant grantedAt\n    }\n\n    ApiUser \"1\" --&gt; \"1\" UserCryptoKeys : CASCADE DELETE\n    ApiUser \"1\" --&gt; \"0..*\" SharedSecret : createdBy (SET NULL)\n    ApiUser \"1\" --&gt; \"0..*\" UserSecretAccess : user (CASCADE)\n    SharedSecret \"1\" --&gt; \"0..*\" UserSecretAccess : secret (CASCADE)\n    ApiUser \"1\" --&gt; \"0..*\" UserSecretAccess : grantedBy\n\n    note for UserCryptoKeys \"Stores user's X25519 key pair\\n- Public key: plaintext\\n- Private key: encrypted with KEK\\n- KEK derived from password via Argon2id\"\n    note for SharedSecret \"Encrypted with random DEK\\n- DEK NOT stored here\\n- Each user has own encrypted DEK copy\\n- Multiple users can access same secret\"\n    note for UserSecretAccess \"Composite PK: (secret_id, user_id)\\nStores DEK encrypted via X25519 key agreement:\\n1. Derive shared secret (user's private + granter's - public)\\n2. Encrypt DEK with shared secret (AES-GCM)\\n3. User decrypts DEK with their private key\"\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#cascade-delete-behavior","title":"Cascade Delete Behavior","text":"<p>When an ApiUser is deleted: 1. UserCryptoKeys: Deleted via JPA <code>@OneToOne(cascade = CascadeType.REMOVE)</code> (application-level) 2. UserSecretAccess (where user had access): Deleted via database FK <code>ON DELETE CASCADE</code> (<code>@OnDelete(CASCADE)</code>) 3. SharedSecret (created by user): <code>createdBy</code> set to NULL via database FK <code>ON DELETE SET NULL</code> (<code>@OnDelete(SET_NULL)</code>)    - Secret remains in database    - Becomes orphaned but still accessible to other users who have access</p> <p>When a SharedSecret is deleted: - UserSecretAccess records: Deleted via database FK <code>ON DELETE CASCADE</code></p> <p>Why mixed cascade strategy? - JPA cascade for <code>UserCryptoKeys</code>: Simple 1:1 relationship, no circular references - Database cascade for <code>UserSecretAccess</code>: Avoids Hibernate circular reference issues when deleting through complex relationship graph - Database SET NULL for <code>SharedSecret.createdBy</code>: Allows secrets to outlive their creator</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#jpahibernate-considerations","title":"JPA/Hibernate Considerations","text":""},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#entity-design-immutable-data-classes","title":"Entity Design: Immutable Data Classes","text":"<p>All entities use Kotlin <code>data class</code> with <code>val</code> (immutable) fields for thread safety and functional programming benefits.</p> <pre><code>@Entity\ndata class UserCryptoKeys(\n    @Id val userId: Long,\n    val publicKey: ByteArray,\n    val encryptedPrivateKey: ByteArray,\n    // ... immutable fields\n    @Version var version: Long? = null  // MUST be var!\n)\n</code></pre> <p>Why immutable? - Crypto keys shouldn't be accidentally modified - Thread-safe - Better functional programming semantics</p> <p>The <code>@Version</code> requirement:</p> <p>When using immutable fields with <code>.copy()</code>, you MUST add a <code>@Version</code> field:</p> <pre><code>// Without @Version: FAILS\nval keys = repo.findById(userId).orElseThrow()\nval updated = keys.copy(encryptedPrivateKey = newKey)\nrepo.save(updated)  // \ud83d\udca5 StaleObjectStateException\n\n// With @Version: WORKS\n@Version var version: Long? = null  // In entity\n</code></pre> <p>Why? - <code>.copy()</code> creates a detached entity (new object instance) - Hibernate can't tell if it's safe to merge without version tracking - <code>@Version</code> enables optimistic locking and safe merging - Bonus: Prevents lost updates during concurrent modifications</p> <p>See: Hibernate Optimistic Locking</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#onetoone-relationships-without-mapsid","title":"OneToOne Relationships Without <code>@MapsId</code>","text":"<p>Initial attempt used <code>@MapsId</code> but it requires the relationship to be non-null during persist:</p> <pre><code>// \u274c FAILS - @MapsId requires user to be non-null\n@OneToOne\n@MapsId\n@JoinColumn(name = \"user_id\")\nval user: ApiUser? = null\n</code></pre> <p>Solution: Use manual ID + read-only relationship:</p> <pre><code>// \u2705 WORKS\n@Id\nval userId: Long,  // Manual ID\n\n@OneToOne\n@JoinColumn(name = \"user_id\", insertable = false, updatable = false)\nval user: ApiUser? = null  // Read-only navigation property\n</code></pre> <p>How it works: - <code>userId</code> is the PK and FK (same value) - <code>user</code> is just for navigation (lazy-loaded when accessed) - <code>insertable/updatable = false</code> prevents cascade issues - No detached entity problems!</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#delete-methods-need-annotations","title":"Delete Methods Need Annotations","text":"<p>Spring Data JPA delete methods require both <code>@Modifying</code> and <code>@Transactional</code>:</p> <pre><code>interface UserSecretAccessRepository : JpaRepository&lt;...&gt; {\n\n    @Modifying\n    @Transactional\n    fun deleteBySecretIdAndUserId(secretId: UUID, userId: Long)\n}\n</code></pre> <p>Why? - <code>@Modifying</code>: Marks method as data-modifying operation - <code>@Transactional</code>: Ensures EntityManager has active transaction - Without them: <code>TransactionRequiredException</code></p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#bytearray-equality","title":"ByteArray Equality","text":"<p>JPA entities with <code>ByteArray</code> fields need custom <code>equals()</code>/<code>hashCode()</code>:</p> <pre><code>@Entity\ndata class UserCryptoKeys(...) {\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (javaClass != other?.javaClass) return false\n        other as UserCryptoKeys\n        return userId == other.userId  // ID-based equality\n    }\n\n    override fun hashCode(): Int = userId.hashCode()\n}\n</code></pre> <p>Why? - <code>ByteArray.equals()</code> checks reference equality, not content - Data class default <code>equals()</code> breaks for byte arrays - Solution: ID-based equality for entities</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#testing-strategy","title":"Testing Strategy","text":""},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#two-tier-approach-unit-integration","title":"Two-Tier Approach: Unit + Integration","text":"<p>We maintain both test types for different purposes:</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#unit-tests-servicetestkt","title":"Unit Tests (<code>ServiceTest.kt</code>)","text":"<ul> <li>Purpose: Fast, isolated, test logic only</li> <li>Uses: Mockito mocks for all repositories</li> <li>Speed: ~2-3 seconds for full suite</li> <li>KDF params: <code>iterations=1, memory=1MB</code> (100x faster)</li> <li>Best for: Regression testing, CI/CD</li> </ul> <p>Key pattern: Real crypto operations, mocked persistence:</p> <pre><code>@BeforeAll\nfun setup() {\n    userKeysRepo = Mockito.mock(UserCryptoKeysRepository::class.java)\n    service = Service(\n        userKeysRepo = userKeysRepo,\n        // ... other mocks\n        kdfIterations = 1,      // Fast KDF\n        kdfMemoryKb = 1024\n    )\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#integration-tests-serviceintegrationtestkt","title":"Integration Tests (<code>ServiceIntegrationTest.kt</code>)","text":"<ul> <li>Purpose: Test real database interactions</li> <li>Uses: Real PostgreSQL via Testcontainers</li> <li>Speed: ~10-15 seconds (includes DB startup)</li> <li>KDF params: Uses service defaults</li> <li>Best for: Catching JPA/Hibernate issues, manual verification</li> </ul> <p>Key pattern: No mocks, real Spring context:</p> <pre><code>@SpringBootTest\nclass ServiceIntegrationTest : IntegrationTest() {\n    @Autowired private lateinit var service: Service\n    @Autowired private lateinit var userKeysRepo: UserCryptoKeysRepository\n    // Real dependencies injected by Spring\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#test-helpers-cache-vs-capture","title":"Test Helpers: Cache vs Capture","text":"<p>Unit tests: Use <code>thenAnswer {}</code> to track saves in maps:</p> <pre><code>private val userKeysCache = mutableMapOf&lt;Long, UserCryptoKeys&gt;()\n\nMockito.`when`(userKeysRepo.save(any())).thenAnswer { invocation -&gt;\n    val keys = invocation.arguments[0] as UserCryptoKeys\n    userKeysCache[keys.userId] = keys  // Track in map\n    keys\n}\n\n// Dynamic lookup (survives password rotation)\nMockito.`when`(userKeysRepo.findById(userId)).thenAnswer {\n    Optional.ofNullable(userKeysCache[userId])  // Always current\n}\n</code></pre> <p>Why <code>thenAnswer {}</code> instead of <code>thenReturn()</code>? - <code>thenReturn()</code> captures value at stub-creation time - <code>thenAnswer {}</code> evaluates dynamically on each call - Needed for password rotation where keys change</p> <p>Integration tests: Just use real repositories, no helpers needed!</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#debugging-transaction-issues","title":"Debugging Transaction Issues","text":"<p>Common error: <code>No EntityManager with actual transaction available</code></p> <p>Cause: Delete/modify operations without <code>@Transactional</code> Solution: Add <code>@Transactional</code> to repository method or service method</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#1-mixing-test-kdf-parameters","title":"1. Mixing Test KDF Parameters","text":"<p>\u274c Wrong:</p> <pre><code>setupMockUserKeys(user, password = \"pass1\")  // Uses KDF defaults\nservice.createSecret(userId, password = \"pass1\")  // Uses test KDF\n// Result: Wrong password error!\n</code></pre> <p>\u2705 Right: Ensure consistent KDF parameters throughout test lifecycle.</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#2-password-mismatches-in-test-helpers","title":"2. Password Mismatches in Test Helpers","text":"<pre><code>// Helper should accept password\nprivate fun createMockSecret(\n    user: ApiUser,\n    value: String,\n    password: String = \"password\"  // Default for convenience\n): UUID\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#3-forgetting-to-clear-sensitive-data","title":"3. Forgetting to Clear Sensitive Data","text":"<p>\u274c Wrong:</p> <pre><code>val kek = deriveKey(password, salt)\nval decrypted = decrypt(data, kek)\nreturn decrypted  // KEK still in memory!\n</code></pre> <p>\u2705 Right:</p> <pre><code>val kek = deriveKey(password, salt)\ntry {\n    return decrypt(data, kek)\n} finally {\n    kek.fill(0)  // Always clear\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#4-assuming-apiuser-is-available","title":"4. Assuming <code>ApiUser</code> is Available","text":"<p>The <code>UserCryptoKeys.user</code> field is often <code>null</code> after creation (lazy-loaded). Don't rely on it:</p> <pre><code>// \u274c May be null\nval user = userKeys.user!!  // NPE risk\n\n// \u2705 Use userId instead\nval userId = userKeys.userId\nval user = apiUserRepo.findById(userId).orElseThrow()\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#performance-tips","title":"Performance Tips","text":""},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#kdf-parameters-tuning","title":"KDF Parameters Tuning","text":"<p>Test on your target hardware:</p> <pre><code>fun measureKDF() {\n    val params = listOf(\n        Pair(1, 1024),      // ~10ms (testing only!)\n        Pair(2, 4096),      // ~50ms\n        Pair(3, 65536),     // ~200ms (default)\n        Pair(4, 65536)      // ~300ms\n    )\n\n    params.forEach { (iter, mem) -&gt;\n        val start = System.currentTimeMillis()\n        Argon2id.derive(password, salt, iter, mem)\n        println(\"Iterations=$iter, Memory=${mem}KB: ${System.currentTimeMillis() - start}ms\")\n    }\n}\n</code></pre> <p>Target: 100-500ms per KDF operation - Too fast: Weak against brute-force - Too slow: Poor UX</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#caching-strategies","title":"Caching Strategies","text":"<p>Cache: - \u2705 Public keys (rarely change) - \u2705 Encrypted data (safe to cache)</p> <p>Never cache: - \u274c Passwords - \u274c KEKs (derived keys) - \u274c Decrypted private keys - \u274c DEKs - \u274c Plaintext secrets</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#database-indexes","title":"Database Indexes","text":"<pre><code>-- Required indexes\nCREATE INDEX idx_user_secret_access_secret ON user_secret_access(secret_id);\nCREATE INDEX idx_user_secret_access_user ON user_secret_access(user_id);\nCREATE INDEX idx_shared_secret_created_by ON shared_secret(created_by);\n\n-- Composite for common query\nCREATE INDEX idx_user_secret_access_lookup\n  ON user_secret_access(secret_id, user_id);\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#memory-management","title":"Memory Management","text":""},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#sensitive-data-lifecycle","title":"Sensitive Data Lifecycle","text":"<pre><code>// 1. Create/derive\nval key = deriveKey(password, salt)\n\n// 2. Use\nval result = encrypt(data, key)\n\n// 3. ALWAYS clear\ntry {\n    // Use key\n} finally {\n    key.fill(0)           // ByteArray\n    privateKey.destroy()   // Key interface\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#verify-clearing-testing","title":"Verify Clearing (Testing)","text":"<pre><code>@Test\nfun `should clear sensitive data after use`() {\n    val password = \"test-password\"\n    val service = spy(Service(...))\n\n    service.accessSecret(userId, password, secretId)\n\n    // Verify no keys remain in heap dumps\n    // (Manual inspection or memory profiler)\n}\n</code></pre> <p>Note: Can't easily unit-test memory clearing, but code review + manual verification is important.</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#migration-path","title":"Migration Path","text":""},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#adding-to-existing-application","title":"Adding to Existing Application","text":"<ol> <li>Create tables (Hibernate auto-DDL or Flyway):</li> </ol> <pre><code>CREATE TABLE user_crypto_keys (...);\nCREATE TABLE shared_secret (...);\nCREATE TABLE user_secret_access (...);\n</code></pre> <ol> <li>Optional: Migrate existing secrets:</li> </ol> <pre><code>fun migrateExistingSecrets() {\n    existingSecrets.forEach { secret -&gt;\n        // Generate DEK, re-encrypt secret\n        // Encrypt DEK with each user's public key\n        // Store in new schema\n    }\n}\n</code></pre> <ol> <li>Gradual rollout:</li> <li>Phase 1: New users only</li> <li>Phase 2: Existing users opt-in</li> <li>Phase 3: Force migration</li> </ol>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#error-attempted-to-assign-id-from-null-one-to-one-property","title":"Error: \"attempted to assign id from null one-to-one property\"","text":"<p>Cause: Using <code>@MapsId</code> with null relationship Fix: Remove <code>@MapsId</code>, use manual ID management</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#error-detached-entity-passed-to-persist","title":"Error: \"detached entity passed to persist\"","text":"<p>Cause: Trying to save entity with detached relationship Fix: Add <code>insertable=false, updatable=false</code> to <code>@JoinColumn</code></p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#error-row-was-updated-or-deleted-by-another-transaction","title":"Error: \"Row was updated or deleted by another transaction\"","text":"<p>Cause: Missing <code>@Version</code> field for immutable entity updates Fix: Add <code>@Version var version: Long? = null</code></p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#error-tag-mismatch-during-decryption","title":"Error: \"Tag mismatch\" during decryption","text":"<p>Cause: Wrong password or corrupted data Solution: Check password, verify KDF parameters match</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#error-no-entitymanager-with-actual-transaction","title":"Error: \"No EntityManager with actual transaction\"","text":"<p>Cause: Delete method without <code>@Transactional</code> Fix: Add <code>@Modifying</code> + <code>@Transactional</code> to repository method</p>"},{"location":"background-and-explanations/security-and-encryption/Implementation-Notes/#code-review-checklist","title":"Code Review Checklist","text":"<p>When reviewing secret sharing code:</p> <ul> <li>[ ] All sensitive byte arrays cleared with <code>.fill(0)</code></li> <li>[ ] Keys destroyed with <code>.destroy()</code> after use</li> <li>[ ] Try-finally blocks protect key lifecycle</li> <li>[ ] No passwords logged or stored</li> <li>[ ] KDF parameters appropriate for environment</li> <li>[ ] Test KDF parameters only in test code</li> <li>[ ] Entity has <code>@Version</code> if using <code>.copy()</code></li> <li>[ ] Delete methods have <code>@Modifying</code> + <code>@Transactional</code></li> <li>[ ] ByteArray entities override <code>equals()</code>/<code>hashCode()</code></li> <li>[ ] Integration tests cover transaction boundaries</li> </ul> <p>Document Version: 1.0 Last Updated: 2025-10-14 Related: Multi-User Secret Sharing with Zero-Knowledge Architecture.md</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/","title":"Multi-User Secret Sharing with Zero-Knowledge Architecture","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#implementation-guide","title":"Implementation Guide","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Problem Statement</li> <li>Solution Architecture</li> <li>Cryptographic Components</li> <li>Data Model</li> <li>Core Operations</li> <li>Security Analysis</li> <li>Implementation Considerations</li> <li>References</li> </ol>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#problem-statement","title":"Problem Statement","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#requirements","title":"Requirements","text":"<ul> <li>Encrypt user secrets so the server cannot read them</li> <li>Allow multiple users to access the same secret</li> <li>Enable granting/revoking access without password sharing</li> <li>Maintain zero-knowledge architecture (server never sees plaintext secrets or passwords)</li> <li>Support asynchronous access grants (users don't need to be online simultaneously)</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#constraints","title":"Constraints","text":"<ul> <li>Cannot store encryption keys server-side</li> <li>Cannot share passwords between users</li> <li>Must be able to decrypt secrets deterministically</li> <li>Need to derive encryption keys from user passwords</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#solution-architecture","title":"Solution Architecture","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#two-layer-encryption-model","title":"Two-Layer Encryption Model","text":"<p>The solution uses a Data Encryption Key (DEK) + Key Encryption Key (KEK) pattern with elliptic curve cryptography:</p> <pre><code>Secret\n  \u2193 encrypted with\nData Encryption Key (DEK) - random, same for all users with access\n  \u2193 encrypted separately for each user with\nX25519 Key Agreement (user's private + granter's public)\n  \u2193 derives\nShared Secret \u2192 encrypts DEK with AES-GCM\n  \u2193 decrypted with\nUser's Private Key (X25519) - encrypted at rest\n  \u2193 encrypted with\nKey Encryption Key (KEK) - derived from password\n  \u2193 derived from\nUser's Password (Argon2id + salt)\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#key-insight","title":"Key Insight","text":"<p>The DEK is shared (conceptually), but each user has their own encrypted copy of it. Users never exchange passwords; instead, they use public-key cryptography to securely share the DEK.</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#cryptographic-components","title":"Cryptographic Components","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#1-password-based-key-derivation-argon2id","title":"1. Password-Based Key Derivation (Argon2id)","text":"<p>Purpose: Derive a symmetric Key Encryption Key (KEK) from user password</p> <p>Algorithm: Argon2id - Time cost: 3 iterations (tune to ~100-500ms) - Memory cost: 64 MB (65536 KB) - Salt: 16 bytes, random per user, stored in database - Output: 256-bit KEK</p> <p>Properties: - Deterministic: same password + salt \u2192 same KEK - Slow by design: makes brute-force expensive - Memory-hard: resistant to GPU/ASIC attacks</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#2-symmetric-encryption-aes-256-gcm","title":"2. Symmetric Encryption (AES-256-GCM)","text":"<p>Purpose: Encrypt private keys and secrets</p> <p>Algorithm: AES-256-GCM - Key size: 256 bits - IV size: 12 bytes (96 bits), random per encryption - Authentication tag: 128 bits (embedded in ciphertext)</p> <p>Used for: - Encrypting user's private X25519 key with KEK - Encrypting secrets with DEK - Encrypting DEK with shared secret from key agreement</p> <p>Properties: - Authenticated encryption (confidentiality + integrity) - Fast and well-supported - IV must be unique per encryption operation</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#3-elliptic-curve-key-agreement-x25519","title":"3. Elliptic Curve Key Agreement (X25519)","text":"<p>Purpose: Enable secure sharing of DEK between users via Diffie-Hellman key agreement</p> <p>Algorithm: X25519 (Curve25519) - Key size: 32 bytes (256 bits) - Each user has a key pair (public + private) - Key agreement produces a shared secret, used with AES-GCM to encrypt DEK</p> <p>Properties: - Public key: can be stored in plaintext, used for key agreement - Private key: encrypted with KEK, used for key agreement - Enables encryption without recipient's password - 10-20x faster than RSA-2048 - Smaller keys (32 bytes vs 256+ bytes for RSA)</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#data-model","title":"Data Model","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#user-crypto-keys","title":"User Crypto Keys","text":"<pre><code>data class UserCryptoKeys(\n    val userId: UUID,\n    val publicKey: ByteArray,           // X25519 public key (32 bytes, plaintext)\n    val encryptedPrivateKey: ByteArray, // X25519 private key (AES-encrypted with KEK)\n    val privateKeyKDFSalt: ByteArray,   // Salt for deriving KEK (16 bytes)\n    val privateKeyIV: ByteArray,        // IV for encrypting private key (12 bytes)\n    val kdfIterations: Int = 3,         // Argon2id parameters (for flexibility)\n    val kdfMemoryKb: Int = 65536\n)\n</code></pre> <p>Storage: One row per user</p> <p>Security notes: - Public key stored in plaintext (it's meant to be public) - Private key encrypted with user's KEK (derived from password) - Salt is not secret, just unique per user - If database is compromised, attacker needs user passwords to decrypt private keys</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#shared-secrets","title":"Shared Secrets","text":"<pre><code>data class SharedSecret(\n    val id: UUID,\n    val name: String,                   // e.g., \"Production API Key\"\n    val encryptedSecret: String,        // Secret encrypted with DEK (Base64)\n    val secretIV: String,               // IV for secret encryption (Base64)\n    val createdBy: UUID,                // User who created the secret\n    val createdAt: Timestamp\n)\n</code></pre> <p>Storage: One row per secret</p> <p>Security notes: - Secret encrypted with a random DEK - DEK is NOT stored here (stored separately per user) - IV is unique for this encryption</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#user-secret-access","title":"User Secret Access","text":"<pre><code>data class UserSecretAccess(\n    val secretId: UUID,                 // Reference to SharedSecret\n    val userId: UUID,                   // User who has access\n    val encryptedDEK: ByteArray,        // DEK encrypted via X25519 key agreement + AES-GCM\n    val dekIV: ByteArray,               // IV for DEK encryption (12 bytes)\n    val grantedBy: UUID,                // User who granted access (used for key agreement)\n    val grantedAt: Timestamp\n)\n</code></pre> <p>Storage: One row per (user, secret) pair</p> <p>Security notes: - Each user has their own encrypted copy of the DEK - DEK encrypted using X25519 key agreement (user's private + granter's public) + AES-GCM - User can decrypt DEK by deriving the same shared secret (requires their password to decrypt private key) - <code>grantedBy</code> indicates whose public key to use for key agreement</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#database-schema-example","title":"Database Schema Example","text":"<pre><code>CREATE TABLE user_crypto_keys (\n    user_id UUID PRIMARY KEY,\n    public_key TEXT NOT NULL,\n    encrypted_private_key TEXT NOT NULL,\n    private_key_kdf_salt VARCHAR(32) NOT NULL,\n    private_key_iv VARCHAR(32) NOT NULL,\n    kdf_iterations INT DEFAULT 3,\n    kdf_memory_kb INT DEFAULT 65536,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE shared_secret (\n    id UUID PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    encrypted_secret TEXT NOT NULL,\n    secret_iv VARCHAR(32) NOT NULL,\n    created_by UUID REFERENCES user_crypto_keys(user_id),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE user_secret_access (\n    secret_id UUID REFERENCES shared_secret(id),\n    user_id UUID REFERENCES user_crypto_keys(user_id),\n    encrypted_dek TEXT NOT NULL,\n    granted_by UUID REFERENCES user_crypto_keys(user_id),\n    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (secret_id, user_id)\n);\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#core-operations","title":"Core Operations","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#1-user-registration-key-setup","title":"1. User Registration / Key Setup","text":"<p>Trigger: New user account creation</p> <p>Process: 1. Generate X25519 key pair (32-byte keys) 2. Generate random salt (16 bytes) 3. Derive KEK from password using Argon2id 4. Encrypt private key with KEK using AES-GCM 5. Store: public key (plaintext), encrypted private key, salt, IV</p> <p>Pseudocode:</p> <pre><code>fun setupUserKeys(userId: UUID, password: String) {\n    // Generate X25519 key pair\n    val keyPair = generateX25519KeyPair()\n\n    // Derive KEK from password\n    val salt = generateRandomBytes(16)\n    val kek = Argon2id.derive(password, salt, iterations=3, memory=65536)\n\n    // Encrypt private key with KEK\n    val iv = generateRandomBytes(12)\n    val encryptedPrivateKey = AES_GCM.encrypt(keyPair.private, kek, iv)\n\n    // Store in database\n    store(UserCryptoKeys(\n        userId = userId,\n        publicKey = keyPair.public.toBase64(),\n        encryptedPrivateKey = encryptedPrivateKey.toBase64(),\n        privateKeyKDFSalt = salt.toBase64(),\n        privateKeyIV = iv.toBase64()\n    ))\n\n    // Clear sensitive data\n    kek.clear()\n    keyPair.private.destroy()\n}\n</code></pre> <p>Security considerations: - Private key never stored in plaintext - KEK never stored, only derived on-demand - Password never stored</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#2-create-and-store-secret","title":"2. Create and Store Secret","text":"<p>Trigger: User creates a new secret to share</p> <p>Note: Also available as <code>createSecret(userId, kek, name, value)</code> using pre-derived KEK for better performance (see Session-Based KEK Storage).</p> <p>Process: 1. Generate random DEK (256-bit key) 2. Encrypt secret with DEK using AES-GCM 3. Get creator's public key 4. Encrypt DEK with creator's public key (so they can access it later) 5. Store: encrypted secret, encrypted DEK for creator</p> <p>Pseudocode:</p> <pre><code>fun createSecret(\n    userId: UUID, \n    secretName: String, \n    secretValue: String\n): UUID {\n    // Generate random DEK\n    val dek = generateRandomBytes(32)\n\n    // Encrypt secret with DEK\n    val secretIV = generateRandomBytes(12)\n    val encryptedSecret = AES_GCM.encrypt(secretValue, dek, secretIV)\n\n    // Store encrypted secret\n    val secretId = UUID.randomUUID()\n    store(SharedSecret(\n        id = secretId,\n        name = secretName,\n        encryptedSecret = encryptedSecret.toBase64(),\n        secretIV = secretIV.toBase64(),\n        createdBy = userId\n    ))\n\n    // Encrypt DEK using X25519 key agreement (creator's own keys)\n    val creatorKeys = getUserKeys(userId)\n    val privateKey = decryptPrivateKey(creatorKeys, password) // Already done above\n    val sharedSecret = X25519_KeyAgreement(privateKey, creatorKeys.publicKey)\n    val dekIV = generateRandomBytes(12)\n    val encryptedDEK = AES_GCM.encrypt(dek, sharedSecret, dekIV)\n\n    // Store access record for creator\n    store(UserSecretAccess(\n        secretId = secretId,\n        userId = userId,\n        encryptedDEK = encryptedDEK,\n        dekIV = dekIV,\n        grantedBy = userId\n    ))\n\n    // Clear sensitive data\n    dek.clear()\n\n    return secretId\n}\n</code></pre> <p>Security considerations: - DEK is random, never derived from password - Same DEK used for all users (but encrypted separately for each) - Secret never stored in plaintext</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#3-access-secret","title":"3. Access Secret","text":"<p>Trigger: User wants to read a secret they have access to</p> <p>Note: Also available as <code>accessSecret(userId, kek, secretId)</code> using pre-derived KEK (see Session-Based KEK Storage).</p> <p>Process: 1. User provides password 2. Derive KEK from password 3. Decrypt user's private key with KEK 4. Retrieve user's encrypted DEK for this secret 5. Decrypt DEK with private key 6. Decrypt secret with DEK 7. Return plaintext secret (clear all keys from memory)</p> <p>Pseudocode:</p> <pre><code>fun accessSecret(\n    secretId: UUID, \n    userId: UUID, \n    password: String\n): String {\n    // 1. Get user's encrypted private key\n    val userKeys = getUserKeys(userId)\n\n    // 2. Derive KEK from password\n    val kek = Argon2id.derive(\n        password, \n        userKeys.privateKeyKDFSalt.fromBase64(),\n        iterations = userKeys.kdfIterations,\n        memory = userKeys.kdfMemoryKb\n    )\n\n    // 3. Decrypt private key with KEK\n    val privateKey = AES_GCM.decrypt(\n        userKeys.encryptedPrivateKey.fromBase64(),\n        kek,\n        userKeys.privateKeyIV.fromBase64()\n    )\n\n    // 4. Get user's encrypted DEK for this secret\n    val access = getUserAccess(secretId, userId)\n\n    // 5. Derive shared secret via X25519 key agreement\n    // Use granter's public key (from grantedBy field)\n    val granterKeys = getUserKeys(access.grantedBy)\n    val sharedSecret = X25519_KeyAgreement(privateKey, granterKeys.publicKey)\n\n    // 6. Decrypt DEK with shared secret\n    val dek = AES_GCM.decrypt(access.encryptedDEK, sharedSecret, access.dekIV)\n\n    // 7. Get and decrypt the secret\n    val secret = getSecret(secretId)\n    val plaintext = AES_GCM.decrypt(\n        secret.encryptedSecret.fromBase64(),\n        dek,\n        secret.secretIV.fromBase64()\n    )\n\n    // 8. Clear all sensitive data from memory\n    kek.clear()\n    privateKey.destroy()\n    dek.clear()\n    sharedSecret.clear()\n\n    return plaintext.toString(Charsets.UTF_8)\n}\n</code></pre> <p>Security considerations: - Password never transmitted or stored - Private key and keys only exist in memory temporarily - Multiple layers of decryption: KEK \u2192 private key \u2192 DEK \u2192 secret - All intermediate keys cleared after use</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#4-grant-access-to-another-user","title":"4. Grant Access to Another User","text":"<p>Trigger: User A wants to share a secret with User B</p> <p>Note: Also available as <code>grantAccess(secretId, granterUserId, granterKEK, granteeUserId)</code> using pre-derived KEK (see Session-Based KEK Storage).</p> <p>Process: 1. User A provides password 2. User A decrypts their private key and retrieves DEK (same as \"Access Secret\") 3. Get User B's public key (no password needed!) 4. Encrypt DEK with User B's public key 5. Store new access record for User B</p> <p>Pseudocode:</p> <pre><code>fun grantAccess(\n    secretId: UUID,\n    granterUserId: UUID,      // User A\n    granterPassword: String,  // User A's password\n    granteeUserId: UUID       // User B\n) {\n    // 1-2. Granter decrypts their private key and gets DEK\n    val granterKeys = getUserKeys(granterUserId)\n    val granterKEK = Argon2id.derive(\n        granterPassword,\n        granterKeys.privateKeyKDFSalt.fromBase64(),\n        iterations = granterKeys.kdfIterations,\n        memory = granterKeys.kdfMemoryKb\n    )\n\n    val granterPrivateKey = AES_GCM.decrypt(\n        granterKeys.encryptedPrivateKey.fromBase64(),\n        granterKEK,\n        granterKeys.privateKeyIV.fromBase64()\n    )\n\n    val granterAccess = getUserAccess(secretId, granterUserId)\n\n    // Decrypt granter's DEK using key agreement with own keys\n    val granterSharedSecret = X25519_KeyAgreement(granterPrivateKey, granterKeys.publicKey)\n    val dek = AES_GCM.decrypt(\n        granterAccess.encryptedDEK,\n        granterSharedSecret,\n        granterAccess.dekIV\n    )\n\n    // 3. Get grantee's public key (no password needed!)\n    val granteeKeys = getUserKeys(granteeUserId)\n\n    // 4. Encrypt DEK for grantee using key agreement (granter's private + grantee's public)\n    val granteeSharedSecret = X25519_KeyAgreement(granterPrivateKey, granteeKeys.publicKey)\n    val dekIV = generateRandomBytes(12)\n    val encryptedDEKForGrantee = AES_GCM.encrypt(dek, granteeSharedSecret, dekIV)\n\n    // 5. Store access record for grantee\n    store(UserSecretAccess(\n        secretId = secretId,\n        userId = granteeUserId,\n        encryptedDEK = encryptedDEKForGrantee,\n        dekIV = dekIV,\n        grantedBy = granterUserId  // Grantee will use granter's public key\n    ))\n\n    // Clear sensitive data\n    granterKEK.clear()\n    granterPrivateKey.destroy()\n    dek.clear()\n    granterSharedSecret.clear()\n    granteeSharedSecret.clear()\n}\n</code></pre> <p>Security considerations: - User B does not need to be online or provide password - User B's password never shared with User A - Only User A's password is needed to perform the grant - Uses User B's public key (which is safe to use without permission)</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#5-revoke-access","title":"5. Revoke Access","text":"<p>Trigger: Remove a user's ability to access a secret</p> <p>Process: 1. Delete the user's access record (encrypted DEK entry) 2. User can no longer decrypt the secret</p> <p>Pseudocode:</p> <pre><code>fun revokeAccess(secretId: UUID, userId: UUID) {\n    deleteUserAccess(secretId, userId)\n}\n</code></pre> <p>Important limitation: - If user already decrypted and saved the secret, revocation doesn't affect saved copies - Consider re-encrypting the secret with a new DEK if you need to fully revoke access - Audit logs recommended to track who accessed what and when</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#security-analysis","title":"Security Analysis","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#what-the-server-can-see","title":"What the Server Can See","text":"<p>\u2705 Stored in database (not secret): - User public keys (meant to be public) - Encrypted private keys (useless without passwords) - KDF salts (not secret, just unique) - Encrypted DEKs (useless without private keys) - Encrypted secrets (useless without DEKs)</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#what-the-server-cannot-see","title":"What the Server Cannot See","text":"<p>\u274c Never stored or transmitted in plaintext: - User passwords - KEKs (Key Encryption Keys) - Private keys (plaintext) - DEKs (plaintext) - Secrets (plaintext)</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#threat-model","title":"Threat Model","text":"<p>If database is compromised: - Attacker gets: all encrypted data, public keys, salts - Attacker needs: user passwords to derive KEKs - Protection: Argon2id makes password brute-forcing expensive (~100-500ms per attempt) - Weak passwords remain vulnerable (use password policies)</p> <p>If single user account is compromised: - Attacker gets: access to secrets that user can access - Attacker cannot: grant themselves access to other secrets - Attacker cannot: decrypt other users' private keys</p> <p>If server is compromised (but not database): - Attacker could: intercept passwords during login - Mitigation: Use TLS, consider client-side key derivation - This is same risk as any password-based system</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#security-properties","title":"Security Properties","text":"<p>\u2705 Zero-knowledge: Server never sees plaintext secrets or passwords \u2705 Forward secrecy: Revoking access prevents future decryption (with limitations) \u2705 Access control: Users can only decrypt secrets they've been explicitly granted access to \u2705 Audit trail: Track who granted access and when \u2705 Brute-force resistance: Argon2id makes password attacks expensive  </p> <p>\u274c Not protected against: Weak user passwords, phishing, compromised endpoints \u274c No password recovery: If user forgets password, their secrets are lost  </p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#implementation-considerations","title":"Implementation Considerations","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#technology-stack-kotlinjvm","title":"Technology Stack (Kotlin/JVM)","text":"<p>Required libraries:</p> <pre><code>// Bouncy Castle for Argon2id and X25519\nimplementation(\"org.bouncycastle:bcprov-jdk18on:1.78.1\")\n\n// Standard Java crypto for AES-GCM\n// (included in JDK, no additional dependencies)\n</code></pre> <p>Key classes: - <code>Argon2BytesGenerator</code> - for key derivation - <code>Cipher</code> with \"AES/GCM/NoPadding\" - for symmetric encryption - <code>KeyPairGenerator</code> with \"X25519\" - for key generation (Bouncy Castle provider) - <code>KeyAgreement</code> with \"X25519\" - for Diffie-Hellman key agreement</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#performance-considerations","title":"Performance Considerations","text":"<p>Key derivation (Argon2id): - Expected time: 100-500ms per operation - Occurs on: login, accessing secrets, granting access - Tuning: Adjust iterations and memory to balance security vs UX - Testing: Use reduced parameters (iterations=1, memory=1024KB) for unit tests</p> <p>X25519 operations: - Key generation: ~5-10ms (done once per user, 10-20x faster than RSA) - Key agreement: &lt;1ms (much faster than RSA encryption/decryption) - Key size: 32 bytes (256 bits, much smaller than RSA)</p> <p>AES-GCM operations: - Very fast: &lt;1ms for typical secret sizes - Scales linearly with data size</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#memory-management","title":"Memory Management","text":"<p>Critical: Clear sensitive data after use</p> <pre><code>// Clear byte arrays\nbyteArray.fill(0)\n\n// Destroy keys\nsecretKey.destroy()\nprivateKey.destroy()\n\n// Use try-finally blocks\nval key = deriveKey(password, salt)\ntry {\n    // Use key\n} finally {\n    key.fill(0)\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#error-handling","title":"Error Handling","text":"<p>Authentication failures: - Wrong password \u2192 KEK derivation succeeds but decryption fails - Catch <code>AEADBadTagException</code> for AES-GCM failures - Return generic \"authentication failed\" (don't leak which step failed)</p> <p>Access control: - Check user has access record before attempting decryption - Return 403 Forbidden if no access record exists</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#testing-strategy","title":"Testing Strategy","text":"<p>Unit tests (fast parameters):</p> <pre><code>class SecretManager(\n    val kdfIterations: Int = 3,\n    val kdfMemoryKb: Int = 65536\n) {\n    companion object {\n        fun forTesting() = SecretManager(\n            kdfIterations = 1,\n            kdfMemoryKb = 1024\n        )\n    }\n}\n</code></pre> <p>Integration tests (real parameters): - Test full flows with production Argon2id settings - Mark as <code>@Tag(\"slow\")</code> or separate test suite - Run less frequently</p> <p>Security tests: - Verify keys are cleared from memory - Test wrong password scenarios - Test unauthorized access attempts - Verify encrypted data format</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#key-rotation","title":"Key Rotation","text":"<p>Rotating user passwords: 1. User provides old and new passwords 2. Derive old KEK, decrypt private key 3. Derive new KEK, re-encrypt private key with new IV 4. Update database with new encrypted private key, new salt, new IV</p> <p>Rotating secrets (for stronger security after revocation): 1. Generate new DEK 2. Re-encrypt secret with new DEK 3. Re-encrypt new DEK for all authorized users 4. Update all records atomically</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#scalability","title":"Scalability","text":"<p>Database: - Index on <code>(secret_id, user_id)</code> for user_secret_access - Consider partitioning by user_id or secret_id for large deployments</p> <p>Caching: - Can cache public keys (they don't change often) - Never cache passwords, KEKs, or decrypted keys - Can cache encrypted data (it's safe)</p> <p>Concurrent access: - Multiple users can access same secret simultaneously (read-only) - Granting access requires transaction isolation to prevent race conditions</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#session-based-kek-storage-pattern-ux-optimization","title":"Session-Based KEK Storage Pattern (UX Optimization)","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#the-performance-problem","title":"The Performance Problem","text":"<p>Argon2id key derivation takes 100-500ms per operation. Every password-based call (<code>createSecret</code>, <code>accessSecret</code>, <code>grantAccess</code>) triggers a full KDF cycle, creating noticeable latency when users perform multiple operations.</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#the-solution-derive-once-store-in-session","title":"The Solution: Derive Once, Store in Session","text":"<p>The implementation derives the KEK once at login and stores it in the HTTP session (server-side, encrypted via HTTPS):</p> <p>How it works: 1. <code>KekDerivationFilter</code> intercepts login POST, extracts password, stores in request attribute 2. <code>Active.handleAuthenticationSuccess()</code> listener fires after successful authentication 3. KEK is derived via <code>service.deriveKEK(userId, password)</code> and stored in session 4. Controllers retrieve KEK from session using <code>session.getUserKek()</code> 5. On logout, KEK is cleared from session</p> <p>Key classes: - <code>KekDerivationFilter</code> (Active.kt:12-38): Captures password from login POST - <code>Active.deriveAndStoreKek()</code> (Active.kt:85-103): Derives and stores KEK after authentication - <code>HttpSession.getUserKek()</code> (KekDerivationFilter.kt:40-41): Extension function to retrieve KEK</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#method-overloads","title":"Method Overloads","text":"<p>All operations have both password-based and KEK-based variants:</p> <pre><code>// Password-based: derives KEK internally (~200ms)\nfun createSecret(userId: Long, password: String, name: String, value: String): UUID\n\n// KEK-based: uses pre-derived KEK (~1ms)\nfun createSecret(userId: Long, kek: ByteArray, name: String, value: String): UUID\n</code></pre> <p>Available KEK overloads: - <code>createSecret(userId, kek, name, value)</code> \u2192 Returns UUID - <code>createSecretEntity(userId, kek, name, value)</code> \u2192 Returns SharedSecret entity - <code>accessSecret(userId, kek, secretId)</code> \u2192 Returns decrypted string - <code>grantAccess(secretId, granterUserId, granterKEK, granteeUserId)</code></p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#usage-in-controllers","title":"Usage in Controllers","text":"<pre><code>@PostMapping(\"/secrets\")\nfun createSecret(request: CreateSecretRequest, session: HttpSession): UUID {\n    val kek = session.getUserKek()  // Fast retrieval\n    return service.createSecret(userId, kek, request.name, request.value)\n}\n</code></pre>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#security-considerations","title":"Security Considerations","text":"<p>Threat: Session hijacking - Attacker with stolen session cookie has KEK access until timeout - Mitigations: HTTPS only, short session timeout (15-30 min), <code>HttpOnly</code> + <code>SameSite=Strict</code> cookies, Spring Session JDBC with encrypted storage</p> <p>Trade-off:</p> Aspect Password-per-Operation Session KEK UX 100-500ms per op &lt;1ms after login Security Password never stored KEK in session (encrypted) Hijacking risk Limited (need password) Full access until timeout <p>When to use each: - Password-per-operation: High-security admin operations, destructive actions requiring confirmation - Session KEK: Normal dashboard operations, frequent access patterns</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#performance-impact","title":"Performance Impact","text":"<p>Before: Login (200ms) + 5 secret accesses (5\u00d7200ms) = 1200ms After: Login (200ms) + 5 secret accesses (5\u00d7&lt;1ms) = ~205ms Improvement: ~6x faster</p>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#references","title":"References","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#cryptographic-standards","title":"Cryptographic Standards","text":"<ul> <li>Argon2: RFC 9106</li> <li>AES-GCM: NIST SP 800-38D</li> <li>X25519: RFC 7748</li> <li>Key Derivation: NIST SP 800-132</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#similar-implementations","title":"Similar Implementations","text":"<ul> <li>Signal: Uses X3DH key agreement protocol (X25519-based)</li> <li>WireGuard: Uses X25519 for key exchange</li> <li>1Password Teams: Uses SRP + RSA for vault sharing</li> <li>Bitwarden: Uses RSA-2048 for organization sharing</li> <li>ProtonMail: Uses PGP-based key exchange</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#best-practices","title":"Best Practices","text":"<ul> <li>OWASP Key Management Cheat Sheet: Link</li> <li>NIST Password Guidelines: SP 800-63B</li> <li>Latacora Cryptographic Right Answers: Blog post</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#appendix-algorithm-choices","title":"Appendix: Algorithm Choices","text":""},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#why-argon2id-over-pbkdf2-or-bcrypt","title":"Why Argon2id over PBKDF2 or bcrypt?","text":"<ul> <li>More resistant to GPU/ASIC attacks (memory-hard)</li> <li>Configurable time and memory costs</li> <li>Winner of Password Hashing Competition (2015)</li> <li>Recommended by OWASP and cryptography experts</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#why-aes-gcm-over-aes-cbc","title":"Why AES-GCM over AES-CBC?","text":"<ul> <li>Authenticated encryption (prevents tampering)</li> <li>No padding oracle attacks</li> <li>Faster than separate encryption + MAC</li> <li>Industry standard for modern applications</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#why-x25519-elliptic-curve-over-rsa","title":"Why X25519 (Elliptic Curve) over RSA?","text":"<ul> <li>Performance: 10-20x faster than RSA-2048 for key operations</li> <li>Key size: 32 bytes vs 256+ bytes for RSA (easier storage, faster transmission)</li> <li>Security: 128-bit equivalent security (same as RSA-2048)</li> <li>Modern standard: Used in Signal, WireGuard, TLS 1.3</li> <li>Constant-time operations: Resistant to timing attacks by design</li> <li>Mature: Well-vetted, standardized in RFC 7748</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#why-two-layer-encryption-dek-kek","title":"Why Two-Layer Encryption (DEK + KEK)?","text":"<ul> <li>Separates concerns: user authentication vs data encryption</li> <li>Enables efficient multi-user access (shared DEK, individual KEKs)</li> <li>Allows key rotation without re-encrypting all data</li> <li>Standard pattern in enterprise key management (AWS KMS, Google KMS, etc.)</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Multi-User%20Secret%20Sharing%20with%20Zero-Knowledge%20Architecture/#glossary","title":"Glossary","text":"<ul> <li>DEK (Data Encryption Key): Symmetric key used to encrypt the actual secret</li> <li>KEK (Key Encryption Key): Symmetric key derived from password, used to encrypt private key</li> <li>KDF (Key Derivation Function): Algorithm to derive cryptographic key from password</li> <li>Salt: Random value added to KDF to ensure unique outputs</li> <li>IV (Initialization Vector): Random value for each encryption to ensure unique ciphertexts</li> <li>Nonce: Same as IV in the context of AES-GCM</li> <li>X25519: Elliptic curve Diffie-Hellman key agreement protocol using Curve25519</li> <li>Key Agreement: Deriving a shared secret from two key pairs without directly transmitting keys</li> <li>GCM: Galois/Counter Mode, an authenticated encryption mode for AES</li> <li>Zero-knowledge: Server cannot access plaintext data even if it wanted to</li> </ul> <p>Document Version: 1.0 Last Updated: 2025-10-13 Author: Implementation Guide for Multi-User Secret Sharing System</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/","title":"Password-Based User Secrets Encryption","text":""},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#overview","title":"Overview","text":"<p>This implementation encrypts user secrets using a password-derived key, without storing any encryption secrets server-side. Users must provide their password to decrypt their secrets.</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#the-problem","title":"The Problem","text":"<p>We need to: - Encrypt user secrets (API keys, tokens, etc.) - NOT store any encryption keys server-side - Derive encryption keys from user passwords - Ensure the same password always produces the same key (for decryption)</p> <p>Challenge: Deterministic key derivation (same password \u2192 same key) is vulnerable to brute-force attacks if not properly protected.</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#the-solution-argon2id-aes-gcm","title":"The Solution: Argon2id + AES-GCM","text":""},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#key-derivation-argon2id","title":"Key Derivation: Argon2id","text":"<p>Why Argon2id? - Winner of the Password Hashing Competition - Makes brute-force attacks computationally expensive (~100-500ms per attempt) - Memory-hard: resistant to GPU/ASIC attacks - Deterministic with salt: same password + salt = same key</p> <p>How it works:</p> <pre><code>encryption_key = Argon2id(password, salt, iterations, memory)\n</code></pre> <p>Key parameters: - Salt: Random 16-byte value, unique per user, stored in database (not secret!) - Iterations: Time cost (typically 3), tune so derivation takes ~100-500ms - Memory: Memory cost (typically 64MB), makes parallel attacks expensive - Output: 256-bit encryption key</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#encryption-aes-256-gcm","title":"Encryption: AES-256-GCM","text":"<p>Why AES-GCM? - Industry standard for authenticated encryption - Provides confidentiality (encryption) AND authenticity (prevents tampering) - Fast and well-supported</p> <p>How it works:</p> <pre><code>ciphertext = AES-GCM-Encrypt(plaintext, key, iv)\n</code></pre> <p>Key parameters: - IV (Initialization Vector): Random 12-byte value, unique per encryption operation - Key: 256-bit key derived from password via Argon2id - Output: Ciphertext with embedded authentication tag</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#what-gets-stored","title":"What Gets Stored","text":""},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#per-user-once","title":"Per User (once):","text":"<ul> <li>KDF Salt (16 bytes, Base64 encoded): Used to derive encryption key</li> <li>Algorithm parameters (optional): iterations, memory cost for future flexibility</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#per-secret","title":"Per Secret:","text":"<ul> <li>Encrypted Data (variable length, Base64 encoded): IV (12 bytes) + ciphertext combined</li> </ul> <p>Storage format:</p> <pre><code>encrypted_value = Base64(IV || ciphertext)\n</code></pre> <p>The IV is prepended to the ciphertext for convenience - it's not secret, just needs to be unique.</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#security-properties","title":"Security Properties","text":""},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#what-this-protects-against","title":"What This Protects Against:","text":"<ul> <li>Database breach: Encrypted secrets are useless without user passwords</li> <li>Weak passwords: Argon2id makes brute-force attacks slow (~100-500ms per guess)</li> <li>Rainbow tables: Unique per-user salts prevent precomputed attacks</li> <li>Tampering: GCM authentication tag detects any modifications</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#what-this-does-not-protect-against","title":"What This Does NOT Protect Against:","text":"<ul> <li>Weak user passwords: Still vulnerable to dictionary attacks (just slower)</li> <li>Compromised passwords: If password is leaked, secrets can be decrypted</li> <li>Password reuse: Users reusing passwords across services</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#important-constraints","title":"Important Constraints:","text":"<ul> <li>No password recovery: If user forgets password, secrets are permanently lost</li> <li>Password required for access: User must provide password on every session</li> <li>Performance impact: ~100-500ms key derivation on login (by design)</li> </ul>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#key-decisions","title":"Key Decisions","text":""},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#why-not-just-hash-passwords","title":"Why Not Just Hash Passwords?","text":"<p>Hashing (like bcrypt) is for verifying passwords, not deriving keys. Each hash uses a random salt, so the same password produces different hashes - incompatible with encryption.</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#why-store-salt","title":"Why Store Salt?","text":"<p>The salt ensures different users with the same password get different keys. It's not secret, just unique. Without it stored, we couldn't reproduce the same key from the password.</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#why-store-iv-with-ciphertext","title":"Why Store IV with Ciphertext?","text":"<p>The IV must be unique for each encryption but doesn't need to be secret. Storing it with the ciphertext is standard practice and simplifies key management.</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#why-base64-encoding","title":"Why Base64 Encoding?","text":"<p>Makes binary data (salt, IV, ciphertext) easy to store in text database columns. Alternative is binary BLOB storage.</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#testing-considerations","title":"Testing Considerations","text":"<p>Argon2id is intentionally slow (~100-500ms). For unit tests: - Use reduced parameters: <code>iterations=1, memory=1024KB</code> (~5-10ms) - Reserve full parameters for integration tests - The slowness is a security feature, not a bug!</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#architecture-trade-offs","title":"Architecture Trade-offs","text":"<p>Pros: - Zero-knowledge architecture: server never sees encryption keys - Strong security with proper password - No server-side secret management complexity</p> <p>Cons: - No password recovery mechanism - User experience: must enter password to decrypt secrets - Performance: noticeable delay on login (by design) - Password strength critical: system security depends entirely on password quality</p>"},{"location":"background-and-explanations/security-and-encryption/Password-Based%20User%20Secrets%20Encryption%20with%20Derived%20Keys/#references","title":"References","text":"<ul> <li>Argon2 RFC 9106</li> <li>NIST Guidelines on Password-Based Key Derivation</li> <li>AES-GCM Specification</li> </ul>"},{"location":"how-to/folder-sync-handbuch/","title":"Benutzerhandbuch: Folder Sync mit S3 Browser","text":""},{"location":"how-to/folder-sync-handbuch/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ul> <li>1. Einleitung</li> <li>2. S3 Browser einrichten<ul> <li>2.1 S3 Browser herunterladen und installieren</li> <li>2.2 Account hinzuf\u00fcgen</li> <li>2.3 Externen Bucket hinzuf\u00fcgen</li> </ul> </li> <li>3. Automatischen Sync konfigurieren<ul> <li>3.1 Aufgabenplaner \u00f6ffnen</li> <li>3.2 Neue Aufgabe erstellen</li> <li>3.3 Allgemeine Einstellungen</li> <li>3.4 Trigger konfigurieren</li> <li>3.5 Aktion definieren</li> <li>3.6 Bedingungen festlegen</li> <li>3.7 Einstellungen anpassen</li> </ul> </li> <li>4. Glossar</li> </ul>"},{"location":"how-to/folder-sync-handbuch/#1-einleitung","title":"1. Einleitung","text":"<p>Dieses Handbuch f\u00fchrt Sie durch die Einrichtung eines automatischen Synchronisationsprozesses zwischen Ihrem lokalen Ordner und Amazon S3 Storage mithilfe des S3 Browsers. Der S3 Browser ist ein leistungsf\u00e4higes Tool, das die Verwaltung von Amazon S3-Ressourcen vereinfacht.</p> <p>In den folgenden Abschnitten erfahren Sie Schritt f\u00fcr Schritt, wie Sie:</p> <ul> <li>Den S3 Browser installieren und konfigurieren</li> <li>Einen externen Bucket hinzuf\u00fcgen</li> <li>Einen automatischen Sync-Vorgang im Windows-Aufgabenplaner einrichten</li> </ul> <p>Befolgen Sie die Anweisungen sorgf\u00e4ltig, um eine reibungslose und effiziente Datensynchronisation zu gew\u00e4hrleisten.</p>"},{"location":"how-to/folder-sync-handbuch/#2-s3-browser-einrichten","title":"2. S3 Browser einrichten","text":""},{"location":"how-to/folder-sync-handbuch/#21-s3-browser-herunterladen-und-installieren","title":"2.1 S3 Browser herunterladen und installieren","text":"<ol> <li>Navigieren Sie zur offiziellen Website: https://s3browser.com/download.aspx</li> <li>Laden Sie die neueste Version des S3 Browsers herunter.</li> <li>F\u00fchren Sie die Installation aus und notieren Sie sich den Installationspfad f\u00fcr sp\u00e4tere Schritte.</li> </ol>"},{"location":"how-to/folder-sync-handbuch/#22-account-hinzufugen","title":"2.2 Account hinzuf\u00fcgen","text":"<ol> <li>Starten Sie den S3 Browser nach der Installation.</li> <li>F\u00fcgen Sie den bereitgestellten Account hinzu:<ul> <li>Verwenden Sie den Access Key, der Ihnen zur Verf\u00fcgung gestellt wurde.</li> <li>Geben Sie den Secret Access Key ein, den Sie erhalten haben.</li> </ul> </li> </ol>"},{"location":"how-to/folder-sync-handbuch/#23-externen-bucket-hinzufugen","title":"2.3 Externen Bucket hinzuf\u00fcgen","text":"<ol> <li>F\u00fcgen Sie den externen Bucket hinzu.</li> <li>Verwenden Sie daf\u00fcr den Bucket-Namen.</li> </ol>"},{"location":"how-to/folder-sync-handbuch/#3-automatischen-sync-konfigurieren","title":"3. Automatischen Sync konfigurieren","text":""},{"location":"how-to/folder-sync-handbuch/#31-aufgabenplaner-offnen","title":"3.1 Aufgabenplaner \u00f6ffnen","text":"<p>\u00d6ffnen Sie den Windows-Aufgabenplaner durch Eingabe von \"taskschd.msc\" im Ausf\u00fchren-Dialog (Windows-Taste + R).</p>"},{"location":"how-to/folder-sync-handbuch/#32-neue-aufgabe-erstellen","title":"3.2 Neue Aufgabe erstellen","text":"<p>Im Aufgabenplaner, w\u00e4hlen Sie in der linken oberen Ecke unter \"Aktionen\" die Option \"Aufgabe erstellen...\" aus.</p> <p></p>"},{"location":"how-to/folder-sync-handbuch/#33-allgemeine-einstellungen","title":"3.3 Allgemeine Einstellungen","text":"<ol> <li>Geben Sie der Aufgabe einen aussagekr\u00e4ftigen Namen, z.B. \"S3 Folder Sync\".</li> <li>W\u00e4hlen Sie \"Unabh\u00e4ngig von der Benutzeranmeldung ausf\u00fchren\" aus.</li> <li>W\u00e4hlen Sie die h\u00f6chsten Berechtigungen aus (\"Mit h\u00f6chsten Privilegien ausf\u00fchren\").</li> <li>W\u00e4hlen Sie \"Windows 10\" als Konfiguration aus.</li> </ol>"},{"location":"how-to/folder-sync-handbuch/#34-trigger-konfigurieren","title":"3.4 Trigger konfigurieren","text":"<ol> <li> <p>Wechseln Sie zum Reiter \"Trigger\" und erstellen Sie zwei separate Trigger:</p> <p>a) Erster Trigger: \"Beim Start\"</p> <ul> <li>W\u00e4hlen Sie \"Beim Start\" aus dem Dropdown-Men\u00fc.</li> <li>Stellen Sie unter \"Erweiterte Einstellungen\" ein:<ul> <li>Aktivieren Sie \"Wiederholen jede:\" und w\u00e4hlen Sie \"5 Minuten\" aus.</li> <li>W\u00e4hlen Sie bei \"Dauer\" die Option \"Unbegrenzt\" aus.</li> </ul> </li> </ul> <p></p> <p>b) Zweiter Trigger: \"Nach einem Zeitplan\"</p> <ul> <li>W\u00e4hlen Sie unter \"Aufgabe starten:\" die Option \"Nach einem Zeitplan\" aus.</li> <li>W\u00e4hlen Sie bei \"Einstellungen\" die Option \"T\u00e4glich\".</li> <li>Stellen Sie das Startdatum auf das aktuelle Datum und die Startzeit auf einen Zeitpunkt ein, der wenige Minuten in der Zukunft liegt. Dies ist wichtig, damit der Trigger garantiert in der Zukunft liegt und sofort aktiv wird.   Beispiel: Wenn es jetzt 14:30 Uhr ist, stellen Sie die Startzeit auf 14:35 Uhr ein.</li> <li>W\u00e4hlen Sie bei \"Dauer\" die Option \"Unbegrenzt\" aus.</li> </ul> <p></p> </li> <li> <p>Best\u00e4tigen Sie jeden Trigger mit \"OK\".</p> </li> </ol>"},{"location":"how-to/folder-sync-handbuch/#35-aktion-definieren","title":"3.5 Aktion definieren","text":"<ol> <li>Wechseln Sie zum Reiter \"Aktionen\" und w\u00e4hlen Sie \"Neu...\" aus.</li> <li>W\u00e4hlen Sie \"Programm starten\" aus dem Dropdown-Men\u00fc aus.</li> <li> <p>Geben Sie im Feld \"Programm/Skript\" den vollst\u00e4ndigen Pfad zum S3 Browser CLI ein:</p> <pre><code>\"C:\\Program Files\\S3 Browser\\s3browser-cli.exe\"\n</code></pre> </li> <li> <p>F\u00fcgen Sie im Feld \"Argumente hinzuf\u00fcgen\" folgenden Befehl ein:</p> <pre><code>/file sync vertama-data-transfer-dev20240830135304492700000001 \\\n    \"C:\\Ihr\\Lokaler\\Ordner\" \\\n    \"s3:vertama-data-transfer-dev20240830135304492700000001/New Folder/\" \\\n    ncdhs\n</code></pre> <p>Ersetzen Sie \"C:\\Ihr\\Lokaler\\Ordner\" mit dem tats\u00e4chlichen Pfad des zu synchronisierenden Ordners.</p> <p></p> </li> </ol>"},{"location":"how-to/folder-sync-handbuch/#36-bedingungen-festlegen","title":"3.6 Bedingungen festlegen","text":"<p>Wechseln Sie zum Reiter \"Bedingungen\" und deaktivieren Sie alle Optionen unter \"Energie\", um den Sync auch im Batteriebetrieb zu erm\u00f6glichen.</p> <p></p>"},{"location":"how-to/folder-sync-handbuch/#37-einstellungen-anpassen","title":"3.7 Einstellungen anpassen","text":"<p>Wechseln Sie zum Reiter \"Einstellungen\" und nehmen Sie folgende Anpassungen vor:</p> <ol> <li>Aktivieren Sie nur diese Optionen:<ul> <li>\"Aufgabe so schnell wie m\u00f6glich nach einem verpassten Start ausf\u00fchren\"</li> <li>\"Falls Aufgabe scheitert, neu starten alle:\"</li> </ul> </li> <li>Deaktivieren Sie alle anderen Optionen. </li> </ol> <p>Klicken Sie abschlie\u00dfend auf \"OK\", um die Aufgabe zu speichern und zu aktivieren.</p>"},{"location":"how-to/folder-sync-handbuch/#4-glossar","title":"4. Glossar","text":"<ul> <li>S3 Browser: Verwaltungstool f\u00fcr Amazon S3 und kompatible Speicherdienste.</li> <li>Amazon S3: Skalierbarer Cloudspeicherdienst von AWS (Amazon Web Services)</li> <li>Bucket: Container f\u00fcr Dateien in Amazon S3.</li> <li>Access Key: Identifikationsschl\u00fcssel f\u00fcr AWS-Dienste.</li> <li>Secret Access Key: Geheimer Authentifizierungsschl\u00fcssel f\u00fcr AWS.</li> <li>Aufgabenplaner: Windows-Tool zur Aufgabenautomatisierung.</li> <li>Trigger: Definierter Ausl\u00f6ser f\u00fcr geplante Aufgaben.</li> <li>Sync: Datenabgleich zwischen zwei Speicherorten.</li> </ul>"}]}